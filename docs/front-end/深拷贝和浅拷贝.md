# 深拷贝和浅拷贝

## 深拷贝&浅拷贝

对于原始数据类型，并没有深浅拷贝的区别，深浅拷贝都是对于引用数据类型而言，如果我们要赋值对象的所有属性都是引用类型可以用浅拷贝

1. `浅拷贝`：只复制一层对象，当对象的属性是引用类型时，实质复制的是其引用，当引用值发生改变时，也会跟着改变

2. `深拷贝`：深拷贝是另外申请了一块内存，内容和原来一样，更改原对象，拷贝对象不会发生改变

## 浅拷贝实现

#### for in 遍历实现

```js

    let shallCopy => obj=>{
      let rst={}
      for(let key in obj){
        //只复制本身的属性（非继承过来的属性）枚举属性
        if(obj.hasOwnProperty(key)){
          rst[key]=obj[key]
        }
      }
      return rst
    }

     let start ={
      name:'古力娜扎',
      age:'22',
      friend:{
        name:'邓超'
      }
    }
    let copyStart=shallCopy(start)
    copyStart.name="热巴"
    copyStart.friend.name='黄渤'
    // 拷贝的第一层层如果是引用类型，拷贝的其实是一个指针，所以拷贝对象改变会影响原对象
    console.log(start.name,opyStart.friend.name) //古力娜扎 黄渤
```

#### Object.assign(target,source) (适用于对象)

可以把 n 个源对象拷贝到目标对象中去（拷贝的是可枚举属性）

```js
let start = {
  name: "古力娜扎",
  age: "22",
  friend: {
    name: "邓超",
  },
};
let returnedTarget = Object.assign({}, start);
```

#### 扩展运算符...

```js
let start = { name: "刘亦菲" };
let newStart = { ...start };
newStart.name = "迪丽热巴";
console.log(start.name); // 刘亦菲
```

#### slice(适用于数组)

```js
let a = [1, 2, 3, 4];
let b = a.slice();
b[0] = 9;
console.log(a); //[1,2,3,4]
```

## 深拷贝实现

#### JSON.parse(JSON.stringify(obj))

```js
let obj1 = {};
let obj = {
  name: "lison",
  hobby: ["羽毛球", "铁山靠"],
  sex: false,
  func: () => 1,
  desc: undefined,
  symbol: Symbol(1),
  date: new Date(),
  nan: NaN,
  inf: Infinity,
  null: null,
  b: obj1,
};
// obj1.a = obj;
let copyObj = JSON.parse(JSON.stringify(obj));
console.log(obj, copyObj);
/*
    1. 转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。
    2. 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。
    3. 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。
    4.undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如JSON.stringify(function(){}) or JSON.stringify(undefined).
    5. 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
    6. 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。
    7. Date 日期调用了 toJSON() 将其转换为了 string 字符串（同 Date.toISOString()），因此会被当做字符串处理。
    8. NaN 和 Infinity 格式的数值及 null 都会被当做 null。
    9. 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。
*/
```

#### 递归实现深拷贝

```js
let deepClone = (obj) => {
  let newObj = Array.isArray(obj) ? [] : {};
  if (obj && typeof obj === "object") {
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        if (obj[key] && typeof obj[key] === "object") {
          newObj[key] = deepClone(obj[key]);
        } else {
          // 如果不是对象直接拷贝
          newObj[key] = obj[key];
        }
      }
    }
  }
  return newObj;
};

let richGirl = {
  name: "开心",
  car: ["宝马", "奔驰", "保时捷"],
  deive: function () {},
  age: undefined,
};

let richBoy = deepClone(richGirl);

richBoy.deive = "渣男开大G";
richBoy.name = "小明";
richBoy.car = ["哈罗单车", "膜拜"];
richBoy.age = 20;

console.log(richGirl);
console.log(richBoy);
```
